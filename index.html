<!DOCTYPE html>
<html lang="en" class="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="./favicon.png" />
		<meta name="viewport" content="width=device-width" />
		
		<link href="./_app/immutable/assets/0.DfPxqV9Z.css" rel="stylesheet">
		<link rel="modulepreload" href="./_app/immutable/entry/start.DA1-jAPM.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/entry.Bttxjn8X.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/scheduler.C0Rco73a.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.BPO80zdS.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/paths.DrNeqyfb.js">
		<link rel="modulepreload" href="./_app/immutable/entry/app.oBKp_sRw.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/index.CETyMYIe.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/0.D_6zhzk2.js">
		<link rel="modulepreload" href="./_app/immutable/nodes/2.CKqm_ogr.js">
		<link rel="modulepreload" href="./_app/immutable/chunks/blogs.I0-HweMk.js">
	</head>
	<body data-sveltekit-preload-data="hover" data-theme="oregano" >
		<div style="display: contents">  <div class="app-bar flex flex-col variant-glass-primary   p-2  " data-testid="app-bar" role="toolbar" aria-label="" aria-labelledby=""> <div class="app-bar-row-main grid items-center grid-cols-[auto_1fr_auto] gap-4 "> <div class="app-bar-slot-lead flex-none flex justify-between items-center "><a href="./" data-svelte-h="svelte-1xwu27k">Dev Blog Home</a></div>  <div class="app-bar-slot-default flex-auto "></div>  <div class="app-bar-slot-trail flex-none flex items-center space-x-4 mx-4"><a href="https://wstrother.github.io" data-svelte-h="svelte-1rk85mq">My Portfolio</a> </div></div>  </div> <div class="content-heading" data-svelte-h="svelte-xam1qv"></div> <div class="content-main"><div class="content-post relative hover"><a href="./django-htmx" class="w-full h-full absolute top-0 left-0 z-10">Â </a> <div class="content-post-heading"><span class="post-title">First Contact with Django and HTMX</span> <span class="post-date">12 May 2024</span></div> <div class="content-post-body preview relative"><div class="content-post-description">Documenting my initial exploration of Django and HTMX by setting out to create a "reactive" UI entirely with templates and HTMX in a Django app.</div> <p>I decided to start writing some dev blogs about the projects that I'm working on since a lot of them are either more exploratory in nature or might take too long or too many resources for me to deploy or package/distribute them. This first entry is going to be about the beginnings of my journey into learning a new stack I want to use for some projects I have planned in the near future. Without further ado, these are my initial thoughts on dipping my toes into the world of Django and HTMX.</p><h2 id="my-foray-through-javascript-frameworks">My Foray through JavaScript Frameworks</h2><p>Over the past several years I've almost entirely focused on using component based JavaScript libraries / frameworks for the personal projects I've worked on. Initially I learned to use React (with the support of a Laravel backend) for the program that I completed to become a certified full stack developer, but I could tell right away it wasn't really for me. I was just never the biggest fan of JSX and the "declarative" approach still doesn't seem like a very natural fit for a component framework, at least IMO.</p><p>Next I built an <a href="https://github.com/wstrother/ahp-twitch-battleships">app in Angular</a> and it ended up combining pretty nicely with RxJS and the real-time Firebase library for my specific use case, (allowing two players to play a game of battleships by catching Pokemon,) but overall the framework itself felt very bulky and boiler-plate heavy. (And my relative inexperience at the time probably didn't help much.) </p><p>As an aside, the choice to deploy with Firebase proved to be a bad one, as the third party repo I was using for image assets went offline several years later, and when I tried to push a fix to production, the Firebase CLI tool decided I didn't have a connected database, (even though I did -- it was still live in production) and when I tried to create a new one with the same schema I couldn't because I (obviously) already had a database. Whomp whomp.</p><p>In the mean time, I had gotten a job offer working on a product that was based on PHP/WordPress but with the occasional use of a Vue singleton to provide AJAX functionality. I decided to use Vue for the take home I was given in the interview process, and as it turns out I liked it a lot, so I used Vue to build a few <a href="https://wstrother.github.io/ssbr-bingo/">small static applications</a> here and there.</p><p>By the time I left that job I had been introduced to Svelte and discovered what is now my favorite pure JavaScript framework. I'm not as big a fan of SvelteKit as Svelte itself, but it's easy enough to work with and it's been my go to over the past year or so. I even made a lot of progress on a more involved project using SvelteKit and the BaaS tool Supabase, which I'm also still a big fan of. (ATM that project is in arrested development because my inconoclastic choice to provide users with Tailwind on the client side throws a wrench into a lot of "automatic" deployment platforms, and I ain't shelling out money for no AWS container right now.)</p><p>I guess for the record I should point out this very blog and my accompanying portfolio website were made with Svelte.</p><h2 id="goold-old-python">Goold Old Python</h2><p>All that aside, I still consider Python to be my favorite programming language and the one I'm most proficient at. I've done a handful of <a href="https://wstrother.github.io/ahp_twitch_bot_site/">smaller projects</a> using it over the years but the main thing holding me back from jumping into a full stack solution like Django was simply just how proficient I had become at building front ends in JavaScript, especially those that need to be reactive, manage global state across multiple front end views, and do anything with AJAX or real-time database APIs.</p><p>Enter HTMX. As soon as I heard about this new paradigm of letting your server drive reactivity on the front end, I knew I had to give it a try, because I knew that it was basically the perfect excuse to try to use Python to replicate the kind of functionality that I'm used to doing with JavaScript. This is the story of my first attempt at doing so.</p><h2 id="reactivizing-the-django-tutorial">"Reactivizing" the Django Tutorial</h2><p>I started to go through the <a href="https://docs.djangoproject.com/en/5.0/intro/tutorial01/">starting tutorial</a> on the Django website just to get a feel for some of the basics. It involves building a "Polls App" that just has a handful of views for teaching about the basics of using templates, connecting them to queries on the database tables and using the model classes directly in the views module to create a POST endpoint, etc.</p><p>I decided this would be the perfect candidate for an exploration of how HTMX can help turn a traditional HTML form action into a more reactive design. A great challenge would be to take a form action that submits the data to a POST endpoint and redirects to a different view and instead have the form simply update it's state: how many votes have been cast, whether the vote has been submitted, and -- most importantly -- a vote percentage bar that would not only animate the bar filling in when the page is loaded, but transition smoothly to its new state when the vote is cast.</p><p>As an additional stipulation, I wanted to ensure that the action of voting would push a new dedicated URL that also works as a permalink. Technically a real implementation would just check against the user model, (or at the very least some kind of local storage token) but I didn't want to bother setting up authentication for this little toy example and I wanted to see how easy it would be to implement this functionality with Django and HTMX. As it turns out, the answer was "surprisingly easy." More on that later.</p><h2 id="the-perils-of-templating">The Perils of Templating</h2><p>I have to say I'm not now, and have never been, the biggest fan of working with rendered templates. I suppose one of the biggest appeals is the WYSIWYG aspect: when debugging or testing in the browser there's never any mystery about how anything ended up in the DOM -- it's all there in the template. But that's kind of undercut by the amount of additional errors that can be introduced due to the extremely weak coupling between the view context and the template variables.</p><p><img src="https://i.imgur.com/e1T0IRF.png" title="Your ctrl + clicks are useless here..." alt="Your ctrl + clicks are useless here..."></p><p>I guess I can't complain, since one of the biggest things drawing me to explore Django is the potential programmatic flexibility I get from working in pure Python. In the final state of my Polls App branch I use a helper function called <code>get_vote_form_view</code> so that I can easily readily generate the views on the <code>/detail</code> and <code>/results</code> routes. They are essentially filling out the same template and differ only in whether or not a context variable is set to signify that the form has been submitted. I even thought about going so far as to use a wrapper pattern so I could just generate the view method right in the URL paths module but I'm not sure if that's the most "Djangonic" approach.</p><p><img src="https://i.imgur.com/w0xYdIK.png" title="Helper function in views.py" alt="Helper function in views.py"></p><p>Still, I can't help but reflect on how nice it would be to just create a component with reactive state logic built in and maybe even have the context variables defined explicitly right there in the same file. I am keeping an open mind though. I often like trying to approach the same problems with a new paradigm in the hopes that it inspires me to think in a new way and gain new insight. Plus Django is pretty mature at this point and I'd wager there are a whole host of strategies and designs that I could learn from. I highly doubt I am the first person to think about these issues.</p><h2 id="htmx-specific-stuff">HTMX Specific Stuff</h2><p>As I stated before, I only had a few simple objectives to start with just to see how it felt implementing them entirely in HTMX. The three categories they fall within:</p><ul><li>Having all the relevant elements update with respect to whether the form has been submitted or not </li><li>Having the form action actually push a new permanent URL that renders the same even when it's requested directly </li><li>A special "vote meter" UI element that has a "loading in" animation when the page is first rendered <em>and</em> a transitional animation to reflect the update to the various vote tallies </li></ul><p>The first objective was as simple as having the view methods provide a context variable that specifies whether the form has been submitted and then employing all the relevant conditional logic. It's interesting to note too that in some sense the HTMX/rendered template approach has an inherent advantage in that <em>all</em> variables tied to state are inherently "reactive" since the rest of the context is also being updated every time the view is re-rendered. I suppose you could argue that its more wasteful to send the entire view again rather than diffing and just updating the elements that have changed, but I gather that's where the flexibility of using HTMX to send smaller partial templates comes in.</p><p><img src="https://i.imgur.com/SygtpgA.png" title="Using a &amp;#39;submitted&amp;#39; context variable in the template" alt="Using a &amp;#39;submitted&amp;#39; context variable in the template"></p><p>Honestly, I don't know enough to gague how those two paradigms actually compare performance wise. I have to be honest that the prospect of maintaining more and more pairings of routes/views/partial templates seems kind of daunting in terms of how much it could complicate the overall code architecture (and the amount of context-to-template couplings which I've already discussed) but I'm open to the idea that there are probably systematized or programmatic approaches that can maximize maintainability while building out more and more features. I'm as new to HTMX as I am to Django so I expect to find a lot of ideas and patterns that will make sense to me as I explore further.</p><p>I will say that with regards to the second objective, the HTMX implementation was ridiculously easy, probably easier than it would be for most SPA-oriented frameworks. It essentially just involves using a helper method in the views file that resolves the template to either a <code>"base_template.html"</code> or <code>"template.html"</code> form based on the HX header. So in the case of the <code>"detail.html"</code> template which renders my voting form, the base version just extends our base HTML template and situates the "view" template within its content block. Then any HTMX actions just need to target that content block to re-render the same view. (And any anchor tags in the view need to use the <code>hx-boost</code> attribute.)</p><p><img src="https://i.imgur.com/bAJ1aJQ.png" title="Template helper functions" alt="Template helper functions"></p><p>Now we come to the third objective, which ultimately proved to be the most prickly. I mean, the solution ultimately is a very "simple" one but it does leave me with questions about the implementation of HTMX that I'd like to resolve definitively. The reason I wanted this UI element to have distinct animations for loading in and changing state was to make sure I fully understood how the HTMX update cycle actually effects the DOM.</p><p>This UI element uses its own component template that I named <code>"vote_meter.html"</code> and the idea is to get a bar graph view of the vote percentage that each option has. Obviously I chose to implement this with inline styling that specifies the CSS <code>width</code> property, and since I set out to achieve all the behaviors I wanted with just HTMX I didn't want to implement some kind of JS function to animate the width directly when the element mounts. (That would be overly complicated anyway IMO.) I just created a CSS animation that uses the <code>translateX()</code> function (along with having the parent div hide overflow) to show the meter "filling up" from left to right.</p><p><img src="https://i.imgur.com/Oc9lbik.png" title="Loading animation CSS" alt="Loading animation CSS">
<img src="https://i.imgur.com/bFenqZs.gif" title="Vote meter loading animation" alt="Vote meter loading animation"></p><p>As you can imagine, the transition animation should be as simple as setting a CSS <code>transition</code> value as well. The HTMX documentation outlines this use case pretty explicitly:</p><blockquote><p>When new content is received from a server, before the content is swapped in, the existing content of the page is examined for elements that match by theÂ <code>id</code>Â attribute. If a match is found for an element in the new content, the attributes of the old content are copied onto the new element before the swap occurs. The new content is then swapped in, but with theÂ <em>old</em>Â attribute values. Finally, the new attribute values are swapped in, after a âsettleâ delay (20ms by default). A little crazy, but this is what allows CSS transitions to work without any javascript by the developer.</p></blockquote><p>This poses a bit of a problem however: when the new vote meter element is received from the server, the attributes from the old element -- including our loading animation class -- are also copied before being removed again shortly thereafter. Because this is technically a new element being mounted to the body of our HTML document, the loading animation is actually going to play again despite the <code>animation</code> property specifying one repeat. The template actually makes use of an additional context variable called <code>loading</code> that specifies whether the HTML document is being rendered for the first time by a normal browser request, rather than an HTMX request. So when the form is submitted and the view is re-rendered and sent back as an HTMX response the loading animation class isn't included, but because of the behavior specified above, this kind of ruins our transition animation as it means the element will briefly try to slide in from the left again. </p><p><img src="https://i.imgur.com/6tpmZ5E.png" title="Template applies the loading class conditionally" alt="Template applies the loading class conditionally">
<img src="https://i.imgur.com/j8MkLlZ.gif" title="Brief flicker as the conflicting animation is removed" alt="Brief flicker as the conflicting animation is removed"></p><p><strong>Full Disclosure</strong>: While trying to recreate this problem for this blog post I did have to manually turn up the settle time to 100ms because the frame rate on my screen recorder is not high enough to make it clear what was going on.</p><p>I couldn't find any explicit guidance on a problem like this with the HTMX documentation itself, but through testing I seem to have stumbled upon something that works: simply setting the "settle" duration to be 0ms. As far as I can see, their documentation doesn't make clear exactly what happens with this kind of edge case, but as far as I can tell it seems to work fine. (At least in Chrome and Edge.) The entire code base of HTMX is pretty small, but I still haven't delved into it to figure out exactly what's happening. If I had to wager a theory, I imagine that HTMX's deferred call to change the element's attributes is somehow "cutting the line" to the next repaint in the browser, but I can't say for certain yet, just like I don't know if this is the "preferred" solution or if there's an entirely different approach I should've used to implement this behavior.</p><p><img src="https://i.imgur.com/YmRPkO7.png" title="Makeshift solution of setting settle time to 0ms" alt="Makeshift solution of setting settle time to 0ms">
<img src="https://i.imgur.com/YwP7sxh.gif" title="Both animations work even after a clean page load" alt="Both animations work even after a clean page load"></p><h2 id="general-orm-stuff">General ORM Stuff</h2><p>I guess this isn't specific to Django but I figure I'd at least make note of some other areas of future research as I put more time into learning this stack, especially because the allure of Python makes it very tempting to eschew direct querying or implementing table views in Postgres or anything like that.</p><p>I guess the only thing to say here is that I'm very much interested in what some more production ready designs look like in terms of using the DB-agnostic API made possible through Django's <code>models</code> module. My last job has made me wary of any potential pain points involving queries to the database. (I'm irattionally annoyed that the Django tutorial builds a query of an entire table and then slices it to the first 5 elements in Python.)</p><p>Take these two lines from my vote endpoint which are essentially cribbed directly from the tutorial: </p><pre class="python"><code>selected_choice.votes = F("votes") + 1   
selected_choice.save()</code></pre><p>I don't understand the need to make it look like you're modifying an object in memory when the whole point is that's not what you're doing. That's just a minor quibble I guess, but what I feel I really need to get more in depth about is the way building custom functionality into model subclasses is actually querying the database under the hood.</p><p>My polls app only defines two tables -- Questions and Choices -- with a simple one-to-many relationship from Questions to Choices. Defining this foreign key relationship apparently makes a special attribute called <code>choice_set</code> available on any objects instantiated from the Question model class, which can be queried to get choice records that are linked to its primary key, even directly within a template.</p><p>Likewise, the choice objects have reference to question objects through the question field (not just the literal value of its primary key), so when does that query happen? There's a circular dependency there, so the object values obviously must be lazy loaded, but since they're ultimately coming from the database its kind of important to know where and when they're actually being asked for. For this project I actually defined custom methods on both model classes that reference the other table, and presumably those queries are carried out synchronously each time the method is called.</p><p>It'd be nice, moving forward, to figure out a strategy for implementing more standard views on the DB programmatically. Maybe that's too Postgres specific to be accommodated by the standard Django library, but it'd be nice to know some kind of general strategy for creating an object that is implemented from a custom query so as to avoid incessant, redundant querying of the database.</p><h2 id="conclusions">Conclusions</h2><p>If it seems anywhere in this blog post that I'm nitpicking or criticizing, I promise I'm not. I'm more just documenting my thought process as I come to a greater understanding of an approach to web development that I'm not as accustomed to. I'd say the prospect of using more Python is still just as enticing as ever, and a lot of the things I've outlined as "challenges" with getting used to HTMX or potential pain points in terms maintaining the constant coupling between URL paths to views to nested template files is more of an opportunity than anything: I like to look at potential "problems" like these as ways to refine my practices to make them more proficient and maintainable.</p><p>I absolutely still find working in Python a more intuitive and comfortable developer experience, despite having spent relatively more time in JavaScript over recent years, and I feel more empowered than anything to figure out a path forward. Moving forward, I feel like the easiest way to do that is just look around at what's already been done and take what I can from the ideas that make the most sense to me. This applies equally to the world of Django and HTMX.</p><p>If you've made it this far, thanks for reading! <a href="https://github.com/wstrother/events_site/tree/polls-tutorial/polls">Full code available here.</a></p> <div class="fade absolute top-0 left-0 w-full h-full"></div></div></div></div> 
			
			<script>
				{
					__sveltekit_57rk9i = {
						base: new URL(".", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("./_app/immutable/entry/start.DA1-jAPM.js"),
						import("./_app/immutable/entry/app.oBKp_sRw.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 2],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
